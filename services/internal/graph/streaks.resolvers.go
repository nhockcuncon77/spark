package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"spark/internal/graph/directives"
	"spark/internal/graph/model"
	"spark/internal/helpers/streaks"
	"spark/internal/models"
	"context"
	"fmt"
)

// CurrentStreak is the resolver for the current_streak field.
func (r *matchStreakResolver) CurrentStreak(ctx context.Context, obj *models.MatchStreak) (int32, error) {
	return int32(obj.CurrentStreak), nil
}

// LongestStreak is the resolver for the longest_streak field.
func (r *matchStreakResolver) LongestStreak(ctx context.Context, obj *models.MatchStreak) (int32, error) {
	return int32(obj.LongestStreak), nil
}

// IsAtRisk is the resolver for the is_at_risk field.
func (r *matchStreakResolver) IsAtRisk(ctx context.Context, obj *models.MatchStreak) (bool, error) {
	return streaks.IsStreakAtRisk(obj), nil
}

// HoursRemaining is the resolver for the hours_remaining field.
func (r *matchStreakResolver) HoursRemaining(ctx context.Context, obj *models.MatchStreak) (*int32, error) {
	hours := streaks.CalculateHoursRemaining(obj)
	if hours == nil {
		return nil, nil
	}
	h := int32(*hours)
	return &h, nil
}

// MatchStreak is the resolver for the matchStreak field.
func (r *queryResolver) MatchStreak(ctx context.Context, matchID string) (*models.MatchStreak, error) {
	_, _, err := directives.GetAuthClaims(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	streak, err := streaks.GetMatchStreak(matchID)
	if err != nil {
		return nil, err
	}

	return streak, nil
}

// MyStreaks is the resolver for the myStreaks field.
func (r *queryResolver) MyStreaks(ctx context.Context) ([]*models.MatchStreak, error) {
	claims, _, err := directives.GetAuthClaims(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	userStreaks, err := streaks.GetUserStreaks(claims.UserID)
	if err != nil {
		return nil, err
	}

	result := make([]*models.MatchStreak, len(userStreaks))
	for i := range userStreaks {
		result[i] = &userStreaks[i]
	}

	return result, nil
}

// MyStreakStats is the resolver for the myStreakStats field.
func (r *queryResolver) MyStreakStats(ctx context.Context) (*model.UserStreakStats, error) {
	claims, _, err := directives.GetAuthClaims(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	totalActive, longestEver, err := streaks.GetUserStreakStats(claims.UserID)
	if err != nil {
		return nil, err
	}

	// Get milestone info for the longest streak
	milestoneInfos := streaks.GetMilestoneInfo(longestEver)
	currentMilestones := make([]*model.StreakMilestone, 0)
	for _, mi := range milestoneInfos {
		if mi.Achieved {
			currentMilestones = append(currentMilestones, &model.StreakMilestone{
				Days:  int32(mi.Days),
				Emoji: mi.Emoji,
				Title: mi.Title,
			})
		}
	}

	return &model.UserStreakStats{
		TotalActiveStreaks: int32(totalActive),
		LongestStreakEver:  int32(longestEver),
		CurrentMilestones:  currentMilestones,
	}, nil
}

// MatchStreak returns MatchStreakResolver implementation.
func (r *Resolver) MatchStreak() MatchStreakResolver { return &matchStreakResolver{r} }

type matchStreakResolver struct{ *Resolver }
