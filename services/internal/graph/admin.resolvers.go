package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"spark/internal/graph/directives"
	"spark/internal/graph/model"
	"spark/internal/helpers/ormcompat"
	"spark/internal/helpers/pushnotify"
	"spark/internal/helpers/subscriptions"
	"spark/internal/helpers/users"
	"spark/internal/models"
	"context"
	"fmt"
	"log"
	"time"

	"github.com/MelloB1989/karma/orm"
)

// checkAdminRole verifies the user has admin or moderator role
func checkAdminRole(ctx context.Context) error {
	claims, _, err := directives.GetAuthClaims(ctx)
	if err != nil {
		return fmt.Errorf("unauthorized")
	}

	user, err := users.GetUserByID(claims.UserID)
	if err != nil || user == nil {
		return fmt.Errorf("user not found")
	}

	if user.Role != "admin" && user.Role != "moderator" {
		return fmt.Errorf("insufficient permissions")
	}

	return nil
}

// AdminBanUser is the resolver for the adminBanUser field.
func (r *mutationResolver) AdminBanUser(ctx context.Context, userID string, banned bool) (*model.AdminUser, error) {
	if err := checkAdminRole(ctx); err != nil {
		return nil, err
	}

	userORM := orm.Load(&models.User{})
	foundUsers, err := ormcompat.GetByFieldEqualsSlice[models.User](userORM, "Id", userID)
	if err != nil {
		return nil, err
	}
	if len(foundUsers) == 0 {
		return nil, fmt.Errorf("user not found")
	}

	user := foundUsers[0]
	user.IsBanned = banned
	user.UpdatedAt = time.Now()

	if err := userORM.Update(&user, user.Id); err != nil {
		return nil, err
	}

	return userToAdminUser(&user), nil
}

// AdminChangeRole is the resolver for the adminChangeRole field.
func (r *mutationResolver) AdminChangeRole(ctx context.Context, userID string, role string) (*model.AdminUser, error) {
	if err := checkAdminRole(ctx); err != nil {
		return nil, err
	}

	// Validate role
	if role != "user" && role != "admin" && role != "moderator" {
		return nil, fmt.Errorf("invalid role: must be user, admin, or moderator")
	}

	userORM := orm.Load(&models.User{})
	foundUsers, err := ormcompat.GetByFieldEqualsSlice[models.User](userORM, "Id", userID)
	if err != nil {
		return nil, err
	}
	if len(foundUsers) == 0 {
		return nil, fmt.Errorf("user not found")
	}

	user := foundUsers[0]
	user.Role = role
	user.UpdatedAt = time.Now()

	if err := userORM.Update(&user, user.Id); err != nil {
		return nil, err
	}

	return userToAdminUser(&user), nil
}

// AdminResolveVerification is the resolver for the adminResolveVerification field.
func (r *mutationResolver) AdminResolveVerification(ctx context.Context, verificationID string, status string, reason *string) (*model.AdminVerification, error) {
	if err := checkAdminRole(ctx); err != nil {
		return nil, err
	}

	verORM := orm.Load(&models.UserVerification{})
	vers, err := ormcompat.GetByFieldEqualsSlice[models.UserVerification](verORM, "Id", verificationID)
	if err != nil {
		return nil, err
	}
	if len(vers) == 0 {
		return nil, fmt.Errorf("verification not found")
	}

	ver := vers[0]
	ver.Status = status
	ver.UpdatedAt = time.Now()

	if err := verORM.Update(&ver, ver.Id); err != nil {
		return nil, err
	}

	// If verified, update user's is_verified status
	if status == "verified" {
		userORM := orm.Load(&models.User{})
		foundUsers, _ := ormcompat.GetByFieldEqualsSlice[models.User](userORM, "Id", ver.UserId)
		if len(foundUsers) > 0 {
			foundUsers[0].IsVerified = true
			foundUsers[0].UpdatedAt = time.Now()
			userORM.Update(&foundUsers[0], foundUsers[0].Id)
		}
	}

	// Get user for response
	user, _ := users.GetUserByID(ver.UserId)

	media := make([]string, 0)
	for _, m := range ver.Media {
		media = append(media, m.Url)
	}

	return &model.AdminVerification{
		ID:        ver.Id,
		UserID:    ver.UserId,
		User:      userToAdminUser(user),
		Media:     media,
		Status:    ver.Status,
		CreatedAt: ver.CreatedAt,
	}, nil
}

// AdminResolveReport is the resolver for the adminResolveReport field.
func (r *mutationResolver) AdminResolveReport(ctx context.Context, reportID string, status string, action *string) (*model.AdminReport, error) {
	if err := checkAdminRole(ctx); err != nil {
		return nil, err
	}

	reportORM := orm.Load(&models.Report{})
	reports, err := ormcompat.GetByFieldEqualsSlice[models.Report](reportORM, "Id", reportID)
	if err != nil {
		return nil, err
	}

	if len(reports) == 0 {
		return nil, fmt.Errorf("report not found")
	}

	report := reports[0]
	report.Status = status
	report.UpdatedAt = time.Now()

	if err := reportORM.Update(&report, report.Id); err != nil {
		return nil, err
	}

	// Handle action if provided
	if action != nil {
		switch *action {
		case "ban":
			userORM := orm.Load(&models.User{})
			foundUsers, _ := ormcompat.GetByFieldEqualsSlice[models.User](userORM, "Id", report.TargetId)
			if len(foundUsers) > 0 {
				foundUsers[0].IsBanned = true
				foundUsers[0].UpdatedAt = time.Now()
				userORM.Update(&foundUsers[0], foundUsers[0].Id)
			}
		case "warn":
			// TODO: Implement warning system
			log.Printf("[Admin] Warning issued to user %s for report %s", report.TargetId, report.Id)
		}
	}

	reporter, _ := users.GetUserByID(report.UserId)
	target, _ := users.GetUserByID(report.TargetId)

	media := make([]string, 0)
	for _, m := range report.Media {
		media = append(media, m.Url)
	}

	return &model.AdminReport{
		ID:             report.Id,
		UserID:         report.UserId,
		Reporter:       userToAdminUser(reporter),
		TargetID:       report.TargetId,
		Target:         userToAdminUser(target),
		Reason:         report.Reason,
		AdditionalInfo: &report.AdditionalInfo,
		Media:          media,
		Status:         report.Status,
		CreatedAt:      report.CreatedAt,
	}, nil
}

// AdminSendNotification is the resolver for the adminSendNotification field.
func (r *mutationResolver) AdminSendNotification(ctx context.Context, input model.MassNotificationInput) (*model.MassNotificationResult, error) {
	if err := checkAdminRole(ctx); err != nil {
		return nil, err
	}

	// If specific user IDs provided, send to them
	if input.UserIds != nil && len(input.UserIds) > 0 {
		notification := pushnotify.PushNotification{
			Title:     input.Title,
			Body:      input.Body,
			ChannelId: "announcements",
		}

		if err := pushnotify.SendToUsers(input.UserIds, notification); err != nil {
			return &model.MassNotificationResult{
				Success:     false,
				SentCount:   0,
				FailedCount: int32(len(input.UserIds)),
				Message:     strPtr(fmt.Sprintf("Failed to send: %v", err)),
			}, nil
		}

		return &model.MassNotificationResult{
			Success:     true,
			SentCount:   int32(len(input.UserIds)),
			FailedCount: 0,
			Message:     strPtr("Notifications sent successfully"),
		}, nil
	}

	// Send to segment
	segment := "all"
	if input.Segment != nil {
		segment = *input.Segment
	}

	if err := pushnotify.SendMassNotification(input.Title, input.Body, segment); err != nil {
		return &model.MassNotificationResult{
			Success:     false,
			SentCount:   0,
			FailedCount: 0,
			Message:     strPtr(fmt.Sprintf("Failed to send: %v", err)),
		}, nil
	}

	return &model.MassNotificationResult{
		Success:     true,
		SentCount:   0, // Unknown count for mass notification
		FailedCount: 0,
		Message:     strPtr("Mass notification sent to segment: " + segment),
	}, nil
}

// AdminGrantSubscription is the resolver for the adminGrantSubscription field.
func (r *mutationResolver) AdminGrantSubscription(ctx context.Context, userID string, planID string, durationDays int32) (bool, error) {
	if err := checkAdminRole(ctx); err != nil {
		return false, err
	}

	periodStart := time.Now()
	periodEnd := periodStart.AddDate(0, 0, int(durationDays))

	_, err := subscriptions.CreateSubscription(
		userID,
		planID,
		"manual",
		fmt.Sprintf("admin_grant_%d", time.Now().Unix()),
		"",
		periodStart,
		periodEnd,
	)

	if err != nil {
		return false, err
	}

	log.Printf("[Admin] Granted %s subscription to user %s for %d days", planID, userID, durationDays)
	return true, nil
}

// AdminStats is the resolver for the adminStats field.
func (r *queryResolver) AdminStats(ctx context.Context) (*model.AdminStats, error) {
	if err := checkAdminRole(ctx); err != nil {
		return nil, err
	}

	// These would be real database queries in production
	// For now, return placeholder stats

	userORM := orm.Load(&models.User{})
	var allUsers []models.User
	if res, err := userORM.GetAll(); err == nil {
		if s, ok := res.(*[]models.User); ok {
			allUsers = *s
		} else if s, ok := res.([]models.User); ok {
			allUsers = s
		}
	}
	totalUsers := int32(len(allUsers))

	// Count subscribers by plan
	subscriberCounts := make([]*model.PlanSubscriberCount, 0)
	planCounts := map[string]int32{"free": 0, "plus": 0, "pro": 0, "elite": 0}
	for _, u := range allUsers {
		if u.SubscriptionPlanId != "" {
			planCounts[u.SubscriptionPlanId]++
		} else {
			planCounts["free"]++
		}
	}

	for planID, count := range planCounts {
		if planID != "free" && count > 0 {
			subscriberCounts = append(subscriberCounts, &model.PlanSubscriberCount{
				PlanID:   planID,
				PlanName: planID,
				Count:    count,
			})
		}
	}

	totalSubscribers := planCounts["plus"] + planCounts["pro"] + planCounts["elite"]

	// Count pending items
	verORM := orm.Load(&models.UserVerification{})
	pendingVers, _ := ormcompat.GetByFieldEqualsSlice[models.UserVerification](verORM, "Status", "pending")
	reportORM := orm.Load(&models.Report{})
	pendingReports, _ := ormcompat.GetByFieldEqualsSlice[models.Report](reportORM, "Status", "pending")
	matchORM := orm.Load(&models.Match{})
	var allMatches []models.Match
	if res, err := matchORM.GetAll(); err == nil {
		if s, ok := res.(*[]models.Match); ok {
			allMatches = *s
		} else if s, ok := res.([]models.Match); ok {
			allMatches = s
		}
	}

	return &model.AdminStats{
		TotalUsers:           totalUsers,
		ActiveUsersToday:     0, // Would need activity tracking
		ActiveUsersWeek:      0,
		TotalMatches:         int32(len(allMatches)),
		MatchesToday:         0,
		TotalMessages:        0, // Would need message count
		MessagesToday:        0,
		PendingVerifications: int32(len(pendingVers)),
		PendingReports:       int32(len(pendingReports)),
		TotalSubscribers:     totalSubscribers,
		SubscribersByPlan:    subscriberCounts,
		RevenueThisMonth:     0, // Would need payment integration
	}, nil
}

// AdminUsers is the resolver for the adminUsers field.
func (r *queryResolver) AdminUsers(ctx context.Context, filters *model.AdminUserFilters, page *int32, perPage *int32) (*model.AdminUserList, error) {
	if err := checkAdminRole(ctx); err != nil {
		return nil, err
	}

	pageNum := int32(1)
	perPageNum := int32(20)
	if page != nil {
		pageNum = *page
	}
	if perPage != nil {
		perPageNum = *perPage
	}

	userORM := orm.Load(&models.User{})
	var allUsers []models.User
	if res, err := userORM.GetAll(); err != nil {
		return nil, err
	} else if s, ok := res.(*[]models.User); ok {
		allUsers = *s
	} else if s, ok := res.([]models.User); ok {
		allUsers = s
	}

	// Apply filters
	filteredUsers := make([]models.User, 0)
	for _, u := range allUsers {
		include := true

		if filters != nil {
			if filters.Search != nil && *filters.Search != "" {
				search := *filters.Search
				if !contains(u.FirstName, search) && !contains(u.LastName, search) && !contains(u.Email, search) {
					include = false
				}
			}
			if filters.IsVerified != nil && u.IsVerified != *filters.IsVerified {
				include = false
			}
			if filters.IsBanned != nil && u.IsBanned != *filters.IsBanned {
				include = false
			}
			if filters.Role != nil && u.Role != *filters.Role {
				include = false
			}
			if filters.SubscriptionPlanID != nil && u.SubscriptionPlanId != *filters.SubscriptionPlanID {
				include = false
			}
		}

		if include {
			filteredUsers = append(filteredUsers, u)
		}
	}

	total := int32(len(filteredUsers))

	// Paginate
	start := (pageNum - 1) * perPageNum
	end := start + perPageNum
	if start > total {
		start = total
	}
	if end > total {
		end = total
	}

	paginatedUsers := filteredUsers[start:end]
	adminUsers := make([]*model.AdminUser, len(paginatedUsers))
	for i := range paginatedUsers {
		adminUsers[i] = userToAdminUser(&paginatedUsers[i])
	}

	return &model.AdminUserList{
		Users:   adminUsers,
		Total:   total,
		Page:    pageNum,
		PerPage: perPageNum,
	}, nil
}

// AdminUser is the resolver for the adminUser field.
func (r *queryResolver) AdminUser(ctx context.Context, id string) (*model.AdminUser, error) {
	if err := checkAdminRole(ctx); err != nil {
		return nil, err
	}

	user, err := users.GetUserByID(id)
	if err != nil {
		return nil, err
	}

	return userToAdminUser(user), nil
}

// AdminVerifications is the resolver for the adminVerifications field.
func (r *queryResolver) AdminVerifications(ctx context.Context, status *string, page *int32, perPage *int32) ([]*model.AdminVerification, error) {
	if err := checkAdminRole(ctx); err != nil {
		return nil, err
	}

	verORM := orm.Load(&models.UserVerification{})
	var vers []models.UserVerification
	if status != nil {
		vers, _ = ormcompat.GetByFieldEqualsSlice[models.UserVerification](verORM, "Status", *status)
	} else if res, err := verORM.GetAll(); err == nil {
		if s, ok := res.(*[]models.UserVerification); ok {
			vers = *s
		} else if s, ok := res.([]models.UserVerification); ok {
			vers = s
		}
	}

	result := make([]*model.AdminVerification, len(vers))
	for i, v := range vers {
		user, _ := users.GetUserByID(v.UserId)
		media := make([]string, 0)
		for _, m := range v.Media {
			media = append(media, m.Url)
		}
		result[i] = &model.AdminVerification{
			ID:        v.Id,
			UserID:    v.UserId,
			User:      userToAdminUser(user),
			Media:     media,
			Status:    v.Status,
			CreatedAt: v.CreatedAt,
		}
	}

	return result, nil
}

// AdminReports is the resolver for the adminReports field.
func (r *queryResolver) AdminReports(ctx context.Context, status *string, page *int32, perPage *int32) ([]*model.AdminReport, error) {
	if err := checkAdminRole(ctx); err != nil {
		return nil, err
	}

	reportORM := orm.Load(&models.Report{})
	var reports []models.Report
	if status != nil {
		reports, _ = ormcompat.GetByFieldEqualsSlice[models.Report](reportORM, "Status", *status)
	} else if res, err := reportORM.GetAll(); err == nil {
		if s, ok := res.(*[]models.Report); ok {
			reports = *s
		} else if s, ok := res.([]models.Report); ok {
			reports = s
		}
	}

	result := make([]*model.AdminReport, len(reports))
	for i, r := range reports {
		reporter, _ := users.GetUserByID(r.UserId)
		target, _ := users.GetUserByID(r.TargetId)
		media := make([]string, 0)
		for _, m := range r.Media {
			media = append(media, m.Url)
		}
		result[i] = &model.AdminReport{
			ID:             r.Id,
			UserID:         r.UserId,
			Reporter:       userToAdminUser(reporter),
			TargetID:       r.TargetId,
			Target:         userToAdminUser(target),
			Reason:         r.Reason,
			AdditionalInfo: &r.AdditionalInfo,
			Media:          media,
			Status:         r.Status,
			CreatedAt:      r.CreatedAt,
		}
	}

	return result, nil
}

// Helper functions

func userToAdminUser(user *models.User) *model.AdminUser {
	if user == nil {
		return nil
	}
	return &model.AdminUser{
		ID:                 user.Id,
		FirstName:          user.FirstName,
		LastName:           user.LastName,
		Email:              user.Email,
		Pfp:                &user.Pfp,
		Gender:             &user.Gender,
		IsVerified:         user.IsVerified,
		IsBanned:           user.IsBanned,
		Role:               user.Role,
		SubscriptionPlanID: &user.SubscriptionPlanId,
		CreatedAt:          user.CreatedAt,
		LastActive:         nil, // Would need activity tracking
	}
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 ||
		(len(s) > 0 && len(substr) > 0 && containsIgnoreCase(s, substr)))
}

func containsIgnoreCase(s, substr string) bool {
	for i := 0; i+len(substr) <= len(s); i++ {
		if equalFoldSlice(s[i:i+len(substr)], substr) {
			return true
		}
	}
	return false
}

func equalFoldSlice(a, b string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		ca, cb := a[i], b[i]
		if ca >= 'A' && ca <= 'Z' {
			ca += 'a' - 'A'
		}
		if cb >= 'A' && cb <= 'Z' {
			cb += 'a' - 'A'
		}
		if ca != cb {
			return false
		}
	}
	return true
}
