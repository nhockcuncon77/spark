package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"spark/internal/graph/directives"
	"spark/internal/graph/model"
	"spark/internal/helpers/subscriptions"
	"spark/internal/models"
	"context"
	"fmt"
	"time"
)

// CreateCheckoutSession is the resolver for the createCheckoutSession field.
func (r *mutationResolver) CreateCheckoutSession(ctx context.Context, planID string, billingPeriod string) (*model.CheckoutSession, error) {
	claims, _, err := directives.GetAuthClaims(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Get the plan
	plan, err := subscriptions.GetPlan(planID)
	if err != nil {
		return nil, fmt.Errorf("plan not found: %w", err)
	}

	// TODO: Integrate with DodoPayments or RevenueCat to create actual checkout session
	// For now, return a placeholder that frontend will handle with RevenueCat SDK
	_ = plan

	return &model.CheckoutSession{
		CheckoutURL: fmt.Sprintf("revenuecat://purchase?plan=%s&period=%s&user=%s", planID, billingPeriod, claims.UserID),
		SessionID:   fmt.Sprintf("session_%s_%d", claims.UserID, time.Now().Unix()),
		Provider:    "revcat",
	}, nil
}

// CancelSubscription is the resolver for the cancelSubscription field.
func (r *mutationResolver) CancelSubscription(ctx context.Context) (bool, error) {
	claims, _, err := directives.GetAuthClaims(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthorized")
	}

	if err := subscriptions.CancelSubscription(claims.UserID); err != nil {
		return false, err
	}

	return true, nil
}

// ReactivateSubscription is the resolver for the reactivateSubscription field.
func (r *mutationResolver) ReactivateSubscription(ctx context.Context) (bool, error) {
	claims, _, err := directives.GetAuthClaims(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthorized")
	}

	if err := subscriptions.ReactivateSubscription(claims.UserID); err != nil {
		return false, err
	}

	return true, nil
}

// SyncSubscriptionStatus is the resolver for the syncSubscriptionStatus field.
func (r *mutationResolver) SyncSubscriptionStatus(ctx context.Context) (*model.UserSubscriptionStatus, error) {
	claims, _, err := directives.GetAuthClaims(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	return getSubscriptionStatus(claims.UserID)
}

// SubscriptionPlans is the resolver for the subscriptionPlans field.
func (r *queryResolver) SubscriptionPlans(ctx context.Context) ([]*models.SubscriptionPlan, error) {
	plans, err := subscriptions.GetAllPlans()
	if err != nil {
		return nil, err
	}

	// If no plans in DB, return default plans
	if len(plans) == 0 {
		return getDefaultPlans(), nil
	}

	result := make([]*models.SubscriptionPlan, len(plans))
	for i := range plans {
		result[i] = &plans[i]
	}
	return result, nil
}

// MySubscription is the resolver for the mySubscription field.
func (r *queryResolver) MySubscription(ctx context.Context) (*model.UserSubscriptionStatus, error) {
	claims, _, err := directives.GetAuthClaims(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	return getSubscriptionStatus(claims.UserID)
}

// CanPerformAction is the resolver for the canPerformAction field.
func (r *queryResolver) CanPerformAction(ctx context.Context, action string) (bool, error) {
	claims, _, err := directives.GetAuthClaims(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthorized")
	}

	switch action {
	case "swipe":
		canSwipe, _, _ := subscriptions.CanSwipe(claims.UserID)
		return canSwipe, nil
	case "ai_reply":
		canUse, _, _ := subscriptions.CanUseAIReplies(claims.UserID)
		return canUse, nil
	case "see_who_liked":
		return subscriptions.HasFeature(claims.UserID, "see_who_liked"), nil
	case "priority_matching":
		return subscriptions.HasFeature(claims.UserID, "priority_matching"), nil
	case "advanced_filters":
		return subscriptions.HasFeature(claims.UserID, "advanced_filters"), nil
	default:
		return false, nil
	}
}

// SwipesPerDay is the resolver for the swipes_per_day field.
func (r *subscriptionLimitsResolver) SwipesPerDay(ctx context.Context, obj *models.SubscriptionLimits) (int32, error) {
	return int32(obj.SwipesPerDay), nil
}

// AiRepliesPerDay is the resolver for the ai_replies_per_day field.
func (r *subscriptionLimitsResolver) AiRepliesPerDay(ctx context.Context, obj *models.SubscriptionLimits) (int32, error) {
	return int32(obj.AiRepliesPerDay), nil
}

// SuperlikesPerDay is the resolver for the superlikes_per_day field.
func (r *subscriptionLimitsResolver) SuperlikesPerDay(ctx context.Context, obj *models.SubscriptionLimits) (int32, error) {
	return int32(obj.SuperlikesPerDay), nil
}

// BoostsPerMonth is the resolver for the boosts_per_month field.
func (r *subscriptionLimitsResolver) BoostsPerMonth(ctx context.Context, obj *models.SubscriptionLimits) (int32, error) {
	return int32(obj.BoostsPerMonth), nil
}

// PriceMonthly is the resolver for the price_monthly field.
func (r *subscriptionPlanResolver) PriceMonthly(ctx context.Context, obj *models.SubscriptionPlan) (int32, error) {
	return int32(obj.PriceMonthly), nil
}

// PriceYearly is the resolver for the price_yearly field.
func (r *subscriptionPlanResolver) PriceYearly(ctx context.Context, obj *models.SubscriptionPlan) (int32, error) {
	return int32(obj.PriceYearly), nil
}

// SortOrder is the resolver for the sort_order field.
func (r *subscriptionPlanResolver) SortOrder(ctx context.Context, obj *models.SubscriptionPlan) (int32, error) {
	return int32(obj.SortOrder), nil
}

// Plan is the resolver for the plan field.
func (r *userSubscriptionResolver) Plan(ctx context.Context, obj *models.UserSubscription) (*models.SubscriptionPlan, error) {
	plan, err := subscriptions.GetPlan(obj.PlanId)
	if err != nil {
		return nil, err
	}
	return plan, nil
}

// SubscriptionLimits returns SubscriptionLimitsResolver implementation.
func (r *Resolver) SubscriptionLimits() SubscriptionLimitsResolver {
	return &subscriptionLimitsResolver{r}
}

// SubscriptionPlan returns SubscriptionPlanResolver implementation.
func (r *Resolver) SubscriptionPlan() SubscriptionPlanResolver { return &subscriptionPlanResolver{r} }

// UserSubscription returns UserSubscriptionResolver implementation.
func (r *Resolver) UserSubscription() UserSubscriptionResolver { return &userSubscriptionResolver{r} }

type subscriptionLimitsResolver struct{ *Resolver }
type subscriptionPlanResolver struct{ *Resolver }
type userSubscriptionResolver struct{ *Resolver }

// Helper functions

func getSubscriptionStatus(userID string) (*model.UserSubscriptionStatus, error) {
	planID := subscriptions.GetUserPlanID(userID)
	plan, err := subscriptions.GetPlan(planID)
	if err != nil {
		return nil, err
	}

	sub, _ := subscriptions.GetUserSubscription(userID)
	isSubscribed := sub != nil && sub.Status == "active"

	limits := subscriptions.GetUserLimits(userID)
	features := subscriptions.GetUserFeatures(userID)

	// Get remaining swipes
	_, swipesRemaining, _ := subscriptions.CanSwipe(userID)
	_, aiRemaining, _ := subscriptions.CanUseAIReplies(userID)

	return &model.UserSubscriptionStatus{
		PlanID:             planID,
		Plan:               plan,
		IsSubscribed:       isSubscribed,
		Subscription:       sub,
		Limits:             &limits,
		Features:           &features,
		SwipesRemaining:    int32(swipesRemaining),
		AiRepliesRemaining: int32(aiRemaining),
	}, nil
}

func getDefaultPlans() []*models.SubscriptionPlan {
	now := time.Now()
	return []*models.SubscriptionPlan{
		{
			Id:           "free",
			Name:         "Free",
			Description:  "Get started with basic features",
			PriceMonthly: 0,
			PriceYearly:  0,
			Features:     subscriptions.PlanFeatures["free"],
			Limits:       subscriptions.PlanLimits["free"],
			IsActive:     true,
			SortOrder:    0,
			CreatedAt:    now,
		},
		{
			Id:           "plus",
			Name:         "Plus",
			Description:  "See who liked you and more",
			PriceMonthly: 999,
			PriceYearly:  7999,
			Features:     subscriptions.PlanFeatures["plus"],
			Limits:       subscriptions.PlanLimits["plus"],
			IsActive:     true,
			SortOrder:    1,
			CreatedAt:    now,
		},
		{
			Id:           "pro",
			Name:         "Pro",
			Description:  "Priority matching and unlimited AI",
			PriceMonthly: 1999,
			PriceYearly:  15999,
			Features:     subscriptions.PlanFeatures["pro"],
			Limits:       subscriptions.PlanLimits["pro"],
			IsActive:     true,
			SortOrder:    2,
			CreatedAt:    now,
		},
		{
			Id:           "elite",
			Name:         "Elite",
			Description:  "All features unlocked",
			PriceMonthly: 2999,
			PriceYearly:  23999,
			Features:     subscriptions.PlanFeatures["elite"],
			Limits:       subscriptions.PlanLimits["elite"],
			IsActive:     true,
			SortOrder:    3,
			CreatedAt:    now,
		},
	}
}
